<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({"HTML-CSS" : {scale : 75}})
        </script>

        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <link href="https://fonts.googleapis.com/css?family=Cardo" rel="stylesheet" type="text/css">
        <title>Google Summer of Code - Project Blog</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/code.css" />
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a>Google Summer of Code</a>
            </div>
            <div id="subtitle">
                <a href="../">Project Blog</a>
            </div>
        </div>

        <div id="navbar">
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">

          <div id="title"><h1>Training Deep Neural Networks on GPUs</h1></div>
            <div class="info">
    Posted on July 26, 2016
    
</div>

<p>After the successful integration of the deep neural network prototype into TMVA described in the last <a href="./2016-06-27-prototype.mc">post</a>, the next milestone was the development of a GPU backend for the neural network implementation. While the implementation itself was ready relatively quickly, it took until now to get the code ready for integration into the TMVA master branch and test the implementation on the Higgs benchmark dataset.</p>
<h1 id="the-cuda-dnn-backend">The CUDA DNN Backend</h1>
<p>This first implementation of a GPU backend for deep neural networks was developed using <a href="http://www.nvidia.com/object/cuda_home_new.html">NVIDIAs CUDA</a> API. While it is also planned to develop an OpenCL backend for the deep neural network implementation in TMVA, the choice to start with a CUDA implementation was mainly based on me being more familiar with the CUDA API as well as the improved (expected) performance on CUDA devices.</p>
<p>The implementation uses <a href="https://developer.nvidia.com/cublas">cuBLAS</a> for the linear algebra function required in the backend including matrix-matrix multiplication (<a href="http://docs.nvidia.com/cuda/cublas/#cublas-lt-t-gt-gemm">cublasDgemm</a>) and scaled matrix addition (<a href="http://docs.nvidia.com/cuda/cublas/#cublas-lt-t-gt-axpy">cublasDaxpy</a>). For the application of activation functions, computation of their gradients, evaluation of loss and regularization functionals as well as application of dropout, the implementation uses its own kernels in order to minimize external dependencies.</p>
<h2 id="data-transfer">Data Transfer</h2>
<p>Excessive data transfers are the weak spot of GPGPU programming. GPU computing architectures generally dispose of only a limited amount of directly accessible device memory and transferring data from the host is expensive. While the training of deep neural networks may require the transfer of large amounts of training data to the GPU, the transfers are independent from the actual computation and the training data can therefore easily be preloaded and transfers overlapped with computation.</p>
<p>The approach taken here is to continuously stream the data instead of moving all training data to the device at the beginning of the training. This will allow for greater flexibility when running on devices with limited memory or training on very large data sets. The streaming is handled by an architecture specific data loader class. This data loader class provides <code>begin()</code> and <code>end()</code> methods that allow the user to iterate over the batches in a training <a href="http://stackoverflow.com/questions/31155388/meaning-of-an-epoch-in-neural-networks-training">epoch</a>. Each batch object in turn provides access to the training data through <code>GetInput()</code> and <code>GetOutput()</code> member functions, which return a batch of training data in matrix representation. The class structure of the generic training class and the CUDA backend class is illustrated in the figure below.</p>
<div class="figure">
<img src="../images/class_data_loader.png" alt="Figure 1: Cuda implementation
of the data streaming interface for the training of deep neural networks." style="width: 700px;">
<p class="caption">
<strong>Figure 2</strong>: Cuda implementation of the data streaming interface for the training of deep neural networks.
</p>
</div>
<h1 id="benchmark-tests">Benchmark Tests</h1>
<p>In order ensure correctness of the GPU implementation as well as to get a first impression of its computational performance, the CUDA backend was used to train a neural network on the Higgs dataset and its classification performance compared to the original CPU deep neural network implementation.</p>
<p>I encountered some problems with the original implementation of neural networks in TMVA, the one used in my first <a href="2016-04-28-tmva-dnn-1.md">post</a>, which forced me to keep the network relatively small. The network structure is given in the table below:</p>
<table>
<caption><strong>Table 1</strong>: Network structure for the classification benchmarks.</caption>
<thead>
<tr class="header">
<th></th>
<th align="center">Number of Neurons</th>
<th align="center">Activation Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Input Layer</td>
<td align="center">28</td>
<td align="center">Identity</td>
</tr>
<tr class="even">
<td>Hidden Layer 1</td>
<td align="center">100</td>
<td align="center"><span class="math inline">\(\tanh\)</span></td>
</tr>
<tr class="odd">
<td>Hidden Layer 2</td>
<td align="center">50</td>
<td align="center"><span class="math inline">\(\tanh\)</span></td>
</tr>
<tr class="even">
<td>Hidden Layer 3</td>
<td align="center">10</td>
<td align="center"><span class="math inline">\(\tanh\)</span></td>
</tr>
<tr class="odd">
<td>Output Layer</td>
<td align="center">1</td>
<td align="center">Sigmoid</td>
</tr>
</tbody>
</table>
<p>Both implementations were trained using <a href="https://en.wikipedia.org/wiki/Cross_entropy">cross entropy loss</a> and a learning rate of <span class="math inline">\(0.02\)</span>. No regularization such as weight decay or dropout has been applied. During preprocessing, a Gaussian transformation has been applied to the input data, which transformed the input features so that their distributions ressemble Gaussian distributions.</p>
<p>In total three different tests were performed with increasing training set sizes. The first test started out with <span class="math inline">\(5 \times 10^5\)</span> training samples, the second one used <span class="math inline">\(10 ^6\)</span> and the third one <span class="math inline">\(2 \times 10^6\)</span>.</p>
<h2 id="classification-performance">Classification Performance</h2>
<p>As primary performance measure the area under the <a href="https://de.wikipedia.org/wiki/Receiver_Operating_Characteristic">ROC curve</a> of the classifier is used. The results are given in Table 2 below. As expected, the performance increases with the size of the training set. However, the old implementation does not achieve the same classification performance as the GPU implementation. While it is difficult to pinpoint the exact cause of the underperformance of the CPU implementation, it is likely attributable to differences in the training implementation.</p>
<table>
<caption><strong>Table 2</strong>: Classification performance of the CPU and GPU DNN implementations.</caption>
<thead>
<tr class="header">
<th align="center">No. of Training Samples</th>
<th align="center">Area Under ROC Curve - CPU</th>
<th align="center">AreaUnder ROC Curve - GPU</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(5 \times 10^5\)</span></td>
<td align="center">0.824</td>
<td align="center">0.82</td>
</tr>
<tr class="even">
<td align="center"><span class="math inline">\(1 \times 10^6\)</span></td>
<td align="center">0.841</td>
<td align="center">0.826</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(2 \times 10^6\)</span></td>
<td align="center">0.846</td>
<td align="center">0.831</td>
</tr>
</tbody>
</table>
<h2 id="computational-performance">Computational Performance</h2>
<p>The overall computational performance of the two implementations is given by the total training time together with the number of training epochs that were performed. The CPU version was running in parallel on a 32-core Intel Xeon E5 2650 while the GPU implementation was running on a NVIDIA Tesla K20. Looking at the results given in Table 3, one can clearly see that the CPU version outperforms the GPU version with respect to number of training epochs per unit time. This, however, is not very suprising considering that the CPU version is parallelized using <a href="https://people.eecs.berkeley.edu/~brecht/papers/hogwildTR.pdf">Hogwild!</a> style, which means that training on different batches is performed in parallel. Given the size of the training set, the CPU implementation can thus fully exploit the performance of the 32 cores. On the GPU the batches are processed sequentially, but the processing of each batch is parallelized. For small batch sizes, this obviously makes exploiting the full computing power of the GPU difficult.</p>
<table>
<caption><strong>Table 3</strong>: Computational performance of the CPU and GPU DNN implementations.</caption>
<thead>
<tr class="header">
<th align="center">No. of Training Samples</th>
<th align="center">Time CPU [s]</th>
<th align="center">Epochs CPU</th>
<th align="center">Time GPU [s]</th>
<th align="center">Epochs GPU</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(5 \times 10^5\)</span></td>
<td align="center"><span class="math inline">\(714\)</span></td>
<td align="center">160</td>
<td align="center"><span class="math inline">\(1280\)</span></td>
<td align="center">189</td>
</tr>
<tr class="even">
<td align="center"><span class="math inline">\(1 \times 10^6\)</span></td>
<td align="center"><span class="math inline">\(2280\)</span></td>
<td align="center">295</td>
<td align="center"><span class="math inline">\(3260\)</span></td>
<td align="center">224</td>
</tr>
<tr class="odd">
<td align="center"><span class="math inline">\(2 \times 10^6\)</span></td>
<td align="center"><span class="math inline">\(4470\)</span></td>
<td align="center">288</td>
<td align="center"><span class="math inline">\(8103\)</span></td>
<td align="center">182</td>
</tr>
</tbody>
</table>
<h2 id="summary-and-outlook">Summary and Outlook</h2>
<p>The benchmark tests described above mark the first real-world application of the GPU-accelerated implementation of deep neural networks that has been developed in the course of this GSoC project and thus constitute another important step towards multi-architecture, accelerated training of deep neural networks in TMVA.</p>
<p>While the computational performance of the training still leaves room for improvements, the classification performance of the GPU implementation looks promising. The next steps for the GPU implementation are thus an in-depth performance analysis in order to better exploit the computational performance of the device as well as improving the classification performance on the Higgs dataset by refining the network structure and training process.</p>
<p>In parallel to this, also the development of an optimized CPU implementation that fixes the shortcomings of the old implementation as well as an OpenCL backend for the neural network implementation has been started.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
